{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Jotbox Jotbox is a library for generating and verifying JWTs in python It provides a common interface for working with purely stateless JWTs or revokable tokens stored in a central whitelist. Features All JWT encoding and decoding is done using the de-facto standard PyJWT under the hood Optional JWT whitelist for revokable tokens (pluggable storage backend) Redis whitelist support is built in using redis-py Optional idle timeout support to revoke tokens that are not accessed for a given interval Type safe, using generics for an extendable JWT payload model Install pip install jotbox To use the included redis whitelist, you must install redis as well: pip install redis Quickstart import asyncio import secrets from jotbox import Jotbox , Payload , JWTDecodeError from jotbox.whitelist.redis import RedisWhitelist # Define the payload model class AccessPayload ( Payload ): user_id : int # Create our Jotbox instance with some settings jot = Jotbox [ AccessPayload ]( encode_key = secrets . token_hex (), payload_type = AccessPayload , leeway = 10 , expires_in = 7200 , # Expire tokens after 2 hours (optional) # Whitelist is optional, skip this if you don't need revoke support idle_timeout = 600 , # Revoke token after 10 minutes without use whitelist = RedisWhitelist ( \"redis://localhost\" ), ) async def run (): # Create a token token = await jot . create_token ( user_id = 42 ) print ( token . token ) # the encoded token as string # >> eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJqdGkiOiJkMDFlYmVmNjlk... print ( repr ( token . payload )) # The payload object # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # Verify the encoded token payload = await jot . verified_payload ( token . token ) print ( payload ) # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # revoke the token (logout) await jot . revoke_payload ( payload ) try : await jot . verified_payload ( token . token ) except JWTDecodeError as e : print ( repr ( e )) # >> RevokedTokenError('Token ID d682eabf-... has been revoked') loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) See all possible settings in the configuration section","title":"Home"},{"location":"#jotbox","text":"Jotbox is a library for generating and verifying JWTs in python It provides a common interface for working with purely stateless JWTs or revokable tokens stored in a central whitelist.","title":"Jotbox"},{"location":"#features","text":"All JWT encoding and decoding is done using the de-facto standard PyJWT under the hood Optional JWT whitelist for revokable tokens (pluggable storage backend) Redis whitelist support is built in using redis-py Optional idle timeout support to revoke tokens that are not accessed for a given interval Type safe, using generics for an extendable JWT payload model","title":"Features"},{"location":"#install","text":"pip install jotbox To use the included redis whitelist, you must install redis as well: pip install redis","title":"Install"},{"location":"#quickstart","text":"import asyncio import secrets from jotbox import Jotbox , Payload , JWTDecodeError from jotbox.whitelist.redis import RedisWhitelist # Define the payload model class AccessPayload ( Payload ): user_id : int # Create our Jotbox instance with some settings jot = Jotbox [ AccessPayload ]( encode_key = secrets . token_hex (), payload_type = AccessPayload , leeway = 10 , expires_in = 7200 , # Expire tokens after 2 hours (optional) # Whitelist is optional, skip this if you don't need revoke support idle_timeout = 600 , # Revoke token after 10 minutes without use whitelist = RedisWhitelist ( \"redis://localhost\" ), ) async def run (): # Create a token token = await jot . create_token ( user_id = 42 ) print ( token . token ) # the encoded token as string # >> eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJqdGkiOiJkMDFlYmVmNjlk... print ( repr ( token . payload )) # The payload object # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # Verify the encoded token payload = await jot . verified_payload ( token . token ) print ( payload ) # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # revoke the token (logout) await jot . revoke_payload ( payload ) try : await jot . verified_payload ( token . token ) except JWTDecodeError as e : print ( repr ( e )) # >> RevokedTokenError('Token ID d682eabf-... has been revoked') loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) See all possible settings in the configuration section","title":"Quickstart"},{"location":"config/","text":"Jotbox can be configured with the following arguments encode_key Required This key is used to sign your JWTs. It is also used to verify them (unless a separate decode_key is specified) You should use a strong randomly generated string for this and store it securely. decode_key Default: encode_key When specified this token is used to decode your JWTs. (for use with asymmetric signing algorithms) payload_type Default: jotbox.Payload This is the model that is used for creating token payloads. You can subclass and add extra fields that you want encoded in the token. The default payload has the following standard claims: jti , iat , exp (optional) encode_algorithm Default: \"HS512\" Algorithm used to sign JWTs. This can be any algorithm supported by PyJWT. decode_algorithms Default: [\"HS512\", ] A list of algorithms that are accepted when decoding tokens. Any algorithms supported by PyJWT are accepted. leeway Default: 0 (no leeway) Number of seconds of leeway to allow when verifying things like expiry times and idle timeouts. It can be good to set this to a few seconds to account for clock skew. expires_in Default: None (no expiry) Number of seconds of how long new tokens are valid for. By default tokens never expire. The expiry time is encoded in the JWT as exp claim. idle_timeout Default: None (no idle timeout) Number of seconds before a token is deleted from whitelist due to inactivity. This can only be used when whitelist is provided. whitelist Default: None An instance of jotbox.whitelist.base.Whitelist use as a storage backend for whitelisted tokens. Whitelisting is disabled when not provided. jwt_options Default: {} (default pyjwt options) Dict of options forwarded to PyJWT.decode when verifying tokens.","title":"Configuration"},{"location":"payload-model/","text":"The Payload model The Payload is a pydantic model to control and validate the info that's encoded into JWTs. By default it contains the standard JWT claims: jti , iat , exp (optional) You can override it and customize like any pydantic model. E.g. add some user info and make expiry mandatory: from typing import List from jotbox import Payload class MyPayload ( Payload ): email : str permissions : List [ str ] exp : int Pass this to jotbox and use it. from jotbox import Jotbox jot = Jotbox [ MyPayload ]( encode_key = os . environ [ 'MY_SECRET_KEY' ], payload_type = MyPayload , expires_in = 3600 , ... ) Note : the [MyPayload] part of Jotbox[MyPayload] is not required but gives you type safety and better code completion in your IDE Now you can create tokens with your extra fields await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ] ) The arguments passed to create_token are validated with your payload model so passing invalid/wrong type arguments will fail. exp is added automatically by the expires_in setting by you can override it on a case by case basis by passing your own timestamp: import time import math await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ], exp = math . floor ( time . time () + 1800 ) )","title":"Payload model"},{"location":"payload-model/#the-payload-model","text":"The Payload is a pydantic model to control and validate the info that's encoded into JWTs. By default it contains the standard JWT claims: jti , iat , exp (optional) You can override it and customize like any pydantic model. E.g. add some user info and make expiry mandatory: from typing import List from jotbox import Payload class MyPayload ( Payload ): email : str permissions : List [ str ] exp : int Pass this to jotbox and use it. from jotbox import Jotbox jot = Jotbox [ MyPayload ]( encode_key = os . environ [ 'MY_SECRET_KEY' ], payload_type = MyPayload , expires_in = 3600 , ... ) Note : the [MyPayload] part of Jotbox[MyPayload] is not required but gives you type safety and better code completion in your IDE Now you can create tokens with your extra fields await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ] ) The arguments passed to create_token are validated with your payload model so passing invalid/wrong type arguments will fail. exp is added automatically by the expires_in setting by you can override it on a case by case basis by passing your own timestamp: import time import math await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ], exp = math . floor ( time . time () + 1800 ) )","title":"The Payload model"},{"location":"sessions/","text":"Sessions The SessionBox class extends JotBox with features that are particularly useful for working with login sessions. It adds first-class support for the subject ( sub ) claim of JWT. That is often used to encode a user ID or username into a JWT. Currently id only adds support for revoking all tokens created for a particular subject. E.g. you can use this for a \"Log out on all devices\" feature. Here is a quick example: from typing import List import asyncio import secrets from jotbox import SessionBox , Session , RevokedTokenError from jotbox.whitelist.redis import SessionRedisWhitelist # Create our session model # The `sub` claim is of type int, but you can use any type you want UserSession = Session [ int ] sessions = SessionBox [ UserSession , int ]( encode_key = secrets . token_urlsafe (), payload_type = UserSession , whitelist = SessionRedisWhitelist ( \"redis://127.0.0.1\" ), idle_timeout = 3600 , expires_in = 24 * 3600 , leeway = 10 , ) async def run (): token = await sessions . create_token ( sub = 42 ) encoded_token = token . token # Verify the token await sessions . verified_payload ( encoded_token ) # Revoke all tokens for the user await sessions . revoke_subject ( token . payload . sub ) # Now verification fails try : await sessions . verified_payload ( encoded_token ) except RevokedTokenError : print ( \"The token has been revoked\" ) if __name__ == \"__main__\" : loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) To break it down: Session model from jotbox import Session ... UserSession = Session [ int ] This is the model for our payload that gets encded to JWT. This is the same as the default Payload but adds one extra field sub This is a generic class and you must specify the data type type of your sub claim. It can be any type you want, for example if your user IDs are uuids, you can use: from uuid import UUID UserSession = Session [ UUID ] You can also subclass and add extra fields as needed: from typing import List class UserSession ( Session [ UUID ]): permissions : List [ str ] email : str Session whitelist from jotbox.whitelist.redis import SessionRedisWhitelist ... whitelist = SessionRedisWhitelist ( \"redis://127.0.0.1\" ), ... This implementation of redis whitelist is extended from the regular whitelist . It includes the value of sub when storing tokens and adds the ability to delete all tokens of a given sub . You can also use a different storage method by creating your own whitelist class based on jotbox.whitelist.base.SessionWhitelist and implementing the add , touch , exists , delete and delete_sub methods.","title":"Login Sessions"},{"location":"sessions/#sessions","text":"The SessionBox class extends JotBox with features that are particularly useful for working with login sessions. It adds first-class support for the subject ( sub ) claim of JWT. That is often used to encode a user ID or username into a JWT. Currently id only adds support for revoking all tokens created for a particular subject. E.g. you can use this for a \"Log out on all devices\" feature. Here is a quick example: from typing import List import asyncio import secrets from jotbox import SessionBox , Session , RevokedTokenError from jotbox.whitelist.redis import SessionRedisWhitelist # Create our session model # The `sub` claim is of type int, but you can use any type you want UserSession = Session [ int ] sessions = SessionBox [ UserSession , int ]( encode_key = secrets . token_urlsafe (), payload_type = UserSession , whitelist = SessionRedisWhitelist ( \"redis://127.0.0.1\" ), idle_timeout = 3600 , expires_in = 24 * 3600 , leeway = 10 , ) async def run (): token = await sessions . create_token ( sub = 42 ) encoded_token = token . token # Verify the token await sessions . verified_payload ( encoded_token ) # Revoke all tokens for the user await sessions . revoke_subject ( token . payload . sub ) # Now verification fails try : await sessions . verified_payload ( encoded_token ) except RevokedTokenError : print ( \"The token has been revoked\" ) if __name__ == \"__main__\" : loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) To break it down:","title":"Sessions"},{"location":"sessions/#session-model","text":"from jotbox import Session ... UserSession = Session [ int ] This is the model for our payload that gets encded to JWT. This is the same as the default Payload but adds one extra field sub This is a generic class and you must specify the data type type of your sub claim. It can be any type you want, for example if your user IDs are uuids, you can use: from uuid import UUID UserSession = Session [ UUID ] You can also subclass and add extra fields as needed: from typing import List class UserSession ( Session [ UUID ]): permissions : List [ str ] email : str","title":"Session model"},{"location":"sessions/#session-whitelist","text":"from jotbox.whitelist.redis import SessionRedisWhitelist ... whitelist = SessionRedisWhitelist ( \"redis://127.0.0.1\" ), ... This implementation of redis whitelist is extended from the regular whitelist . It includes the value of sub when storing tokens and adds the ability to delete all tokens of a given sub . You can also use a different storage method by creating your own whitelist class based on jotbox.whitelist.base.SessionWhitelist and implementing the add , touch , exists , delete and delete_sub methods.","title":"Session whitelist"},{"location":"whitelist-and-revoke-tokens/","text":"Whitelist and revoke tokens This optional feature gives you the option of revoking tokens on demand or after a certain idle timeout . A revoked token will fail verification. This requires a database backend to store tokens. Support for Redis is built in, but you can also roll your own. The whitelist works by storing the token ID ( jti ) every time you generate a token. The token is stored until its expiry time ( exp ) or idle timeout has elapsed (if your token have no expiry time and you don't use idle timeout they will be stored forever) When you call Jotbox.verified_payload it always checks the whitelist. If the token is not in whitelist it raises a jotbox.RevokedTokenerror Use the redis whitelist The built in redis whitelist is simple to use. Import it like this: from jotbox.whitelist.redis import RedisWhitelist Instantiate from redis URL: ... my_whitelist = RedisWhitelist ( 'redis://localhost' ) If you want more control over how the redis connection pool is created, you can pass in an redis.asyncio.Redis instance directly: ... from redis.asyncio import Redis my_redis = Redis ( ... ) my_whitelist = RedisWhitelist ( my_redis ) You can also set a custom key prefix if you'd like (the default prefix is JB:WHITE: ): my_whitelist = RedisWhitelist ( my_redis , key_prefix = \"WHITELISTED_TOKEN:\" ) Now pass your whitelist when creating the Jotbox instance: jot = Jotbox [ MyPayload ]( ... , whitelist = my_whitelist ) To revoke a token (e.g. when a user logs out), pass the verified payload to revoke_payload : payload = await jot . verified_payload ( encoded_token ) await jot . revoke_payload ( payload ) Idle timeout The idle timeout setting tells jotbox to automatically delete tokens from the whitelist after a number of seconds of inactivity. When used in conjunction with expires_at the token is removed from whitelist once either the idle timeout or expiry time elapses, whichever happens first. This can be particularly useful for login sessions as it allows you to automatically log out the user after a period of inactivity while still allowing a long total expiry time on the session. To use this you need to pass both idle_timeout argument to Jotbox along with whitelist : jot = Jotbox [ MyPayload ]( ... , expires_at = 3600 * 24 , # Expire after 24 hours when not idle idle_timeout = 3600 , # Revoke after 1 hour of inactivity whitelist = my_whitelist ) token = await jot . create_token () encoded_token = token . token # User sends the token in API call valid_payload = await jot . verified_payload ( encoded_token ) # Success await asyncio . sleep ( 3601 ) # No activity during idle timeout await jot . verified_payload ( encoded_token ) # raises RevokedTokenerror(...) Use other storage backends You don't have to use redis for your whitelist. You can create a subclass of the abstract class jotbox.whitelist.base.Whitelist and use any database/storage method you want. You'll need to implement the add , exists , touch and delete methods. Check source code of the redis whitelist for a reference implementation. Note that with redis, expiry times are handled by redis itself. With other databases you may need to explicitly check and clean up expired tokens.","title":"Whitelist and revoke tokens"},{"location":"whitelist-and-revoke-tokens/#whitelist-and-revoke-tokens","text":"This optional feature gives you the option of revoking tokens on demand or after a certain idle timeout . A revoked token will fail verification. This requires a database backend to store tokens. Support for Redis is built in, but you can also roll your own. The whitelist works by storing the token ID ( jti ) every time you generate a token. The token is stored until its expiry time ( exp ) or idle timeout has elapsed (if your token have no expiry time and you don't use idle timeout they will be stored forever) When you call Jotbox.verified_payload it always checks the whitelist. If the token is not in whitelist it raises a jotbox.RevokedTokenerror","title":"Whitelist and revoke tokens"},{"location":"whitelist-and-revoke-tokens/#use-the-redis-whitelist","text":"The built in redis whitelist is simple to use. Import it like this: from jotbox.whitelist.redis import RedisWhitelist Instantiate from redis URL: ... my_whitelist = RedisWhitelist ( 'redis://localhost' ) If you want more control over how the redis connection pool is created, you can pass in an redis.asyncio.Redis instance directly: ... from redis.asyncio import Redis my_redis = Redis ( ... ) my_whitelist = RedisWhitelist ( my_redis ) You can also set a custom key prefix if you'd like (the default prefix is JB:WHITE: ): my_whitelist = RedisWhitelist ( my_redis , key_prefix = \"WHITELISTED_TOKEN:\" ) Now pass your whitelist when creating the Jotbox instance: jot = Jotbox [ MyPayload ]( ... , whitelist = my_whitelist ) To revoke a token (e.g. when a user logs out), pass the verified payload to revoke_payload : payload = await jot . verified_payload ( encoded_token ) await jot . revoke_payload ( payload )","title":"Use the redis whitelist"},{"location":"whitelist-and-revoke-tokens/#idle-timeout","text":"The idle timeout setting tells jotbox to automatically delete tokens from the whitelist after a number of seconds of inactivity. When used in conjunction with expires_at the token is removed from whitelist once either the idle timeout or expiry time elapses, whichever happens first. This can be particularly useful for login sessions as it allows you to automatically log out the user after a period of inactivity while still allowing a long total expiry time on the session. To use this you need to pass both idle_timeout argument to Jotbox along with whitelist : jot = Jotbox [ MyPayload ]( ... , expires_at = 3600 * 24 , # Expire after 24 hours when not idle idle_timeout = 3600 , # Revoke after 1 hour of inactivity whitelist = my_whitelist ) token = await jot . create_token () encoded_token = token . token # User sends the token in API call valid_payload = await jot . verified_payload ( encoded_token ) # Success await asyncio . sleep ( 3601 ) # No activity during idle timeout await jot . verified_payload ( encoded_token ) # raises RevokedTokenerror(...)","title":"Idle timeout"},{"location":"whitelist-and-revoke-tokens/#use-other-storage-backends","text":"You don't have to use redis for your whitelist. You can create a subclass of the abstract class jotbox.whitelist.base.Whitelist and use any database/storage method you want. You'll need to implement the add , exists , touch and delete methods. Check source code of the redis whitelist for a reference implementation. Note that with redis, expiry times are handled by redis itself. With other databases you may need to explicitly check and clean up expired tokens.","title":"Use other storage backends"}]}