{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JotBox JotBox is an extended JWT toolkit for python. Features Type safety Secure JWT encoding and decoding using PyJWT Optional token whitelist with pluggable storage backends (redis backend included) Idle timeout support (with whitelist) Install pip install jotbox To use the included redis whitelist, you must install aredis as well: pip install aredis Quickstart import os import asyncio from jotbox import Jotbox , Payload , TokenVerificationError from jotbox.whitelist.redis import RedisWhitelist class AccessPayload ( Payload ): user_id : int jot = Jotbox [ AccessPayload ]( # Provide the payload type for static type safety encode_key = os . environ [ \"MY_ENCODE_KEY\" ], payload_type = AccessPayload , leeway = 10 , expires_in = 7200 , # Expire tokens after 2 hours (optional) # Whitelist is optional idle_timeout = 600 , # Revoke token after 10 minutes without use whitelist = RedisWhitelist ( \"redis://localhost\" ), ) async def run (): # Create a token token = await jot . create_token ( user_id = 42 ) print ( token . token ) # the encoded token as string # >> eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJqdGkiOiJkMDFlYmVmNjlk... print ( repr ( token . payload )) # The payload object # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # Verify the encoded token payload = await jot . verified_payload ( token . token ) print ( payload ) # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # revoke the token (logout) (this requires whitelist) await jot . revoke_payload ( payload ) try : await jot . verified_payload ( token . token ) except TokenVerificationError as e : print ( repr ( e )) # >> RevokedTokenError('Token ID d682eabf-... has been revoked') loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) See all possible settings in the configuration section","title":"Home"},{"location":"#jotbox","text":"JotBox is an extended JWT toolkit for python.","title":"JotBox"},{"location":"#features","text":"Type safety Secure JWT encoding and decoding using PyJWT Optional token whitelist with pluggable storage backends (redis backend included) Idle timeout support (with whitelist)","title":"Features"},{"location":"#install","text":"pip install jotbox To use the included redis whitelist, you must install aredis as well: pip install aredis","title":"Install"},{"location":"#quickstart","text":"import os import asyncio from jotbox import Jotbox , Payload , TokenVerificationError from jotbox.whitelist.redis import RedisWhitelist class AccessPayload ( Payload ): user_id : int jot = Jotbox [ AccessPayload ]( # Provide the payload type for static type safety encode_key = os . environ [ \"MY_ENCODE_KEY\" ], payload_type = AccessPayload , leeway = 10 , expires_in = 7200 , # Expire tokens after 2 hours (optional) # Whitelist is optional idle_timeout = 600 , # Revoke token after 10 minutes without use whitelist = RedisWhitelist ( \"redis://localhost\" ), ) async def run (): # Create a token token = await jot . create_token ( user_id = 42 ) print ( token . token ) # the encoded token as string # >> eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJqdGkiOiJkMDFlYmVmNjlk... print ( repr ( token . payload )) # The payload object # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # Verify the encoded token payload = await jot . verified_payload ( token . token ) print ( payload ) # >> AccessPayload(jti=UUID('d682eabf-...'), iat=1593638317, user_id=42) # revoke the token (logout) (this requires whitelist) await jot . revoke_payload ( payload ) try : await jot . verified_payload ( token . token ) except TokenVerificationError as e : print ( repr ( e )) # >> RevokedTokenError('Token ID d682eabf-... has been revoked') loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) See all possible settings in the configuration section","title":"Quickstart"},{"location":"blacklist/","text":"Blacklist Tokens can be blacklisted by storing their ID in a database. A blacklisted token will always fail verification. This can be used for example to support a secure logout in a web application. JotBox ships with blacklist backends for redis and postgresql You can also implement your own blacklist with by subclassing the base class For example a rudementary in memory blacklist could be implemented like this: from jotbox.store.base import Blacklist from jotbox.types import TPayload class MemoryBlacklist ( Blacklist [ TPayload ]): def __init__ ( self ) -> None : self . tokens = set () async def add ( self , payload : TPayload ) -> None : self . tokens . add ( payload . jti ) async def exists ( self , payload : TPayload ) -> bool : return payload . jti in self . tokens async def delete ( self , payload : TPayload ) -> None : self . tokens . discard ( payload . jti ) Use the redis blacklist NOTE: This requires aredis to be installed Redis will automatically delete tokens shortly after they expire, so you don't have to worry about cleaning up. By default the token IDs are stored in redis with key prefix \"JB:BLACK:\" . You can change the prefix by passing key_prefix=\"MY:PREFIX:\" when instantiating the blacklist. Use the database blacklist NOTE: This requires databases and aiopg to be installed. Currently only postgresql is supported. You may want to clean up expired token from the blacklist periodically. This can be called on demand to run cleanup. await blacklist . delete_expired ()","title":"Blacklist"},{"location":"blacklist/#blacklist","text":"Tokens can be blacklisted by storing their ID in a database. A blacklisted token will always fail verification. This can be used for example to support a secure logout in a web application. JotBox ships with blacklist backends for redis and postgresql You can also implement your own blacklist with by subclassing the base class For example a rudementary in memory blacklist could be implemented like this: from jotbox.store.base import Blacklist from jotbox.types import TPayload class MemoryBlacklist ( Blacklist [ TPayload ]): def __init__ ( self ) -> None : self . tokens = set () async def add ( self , payload : TPayload ) -> None : self . tokens . add ( payload . jti ) async def exists ( self , payload : TPayload ) -> bool : return payload . jti in self . tokens async def delete ( self , payload : TPayload ) -> None : self . tokens . discard ( payload . jti )","title":"Blacklist"},{"location":"blacklist/#use-the-redis-blacklist","text":"NOTE: This requires aredis to be installed Redis will automatically delete tokens shortly after they expire, so you don't have to worry about cleaning up. By default the token IDs are stored in redis with key prefix \"JB:BLACK:\" . You can change the prefix by passing key_prefix=\"MY:PREFIX:\" when instantiating the blacklist.","title":"Use the redis blacklist"},{"location":"blacklist/#use-the-database-blacklist","text":"NOTE: This requires databases and aiopg to be installed. Currently only postgresql is supported. You may want to clean up expired token from the blacklist periodically. This can be called on demand to run cleanup. await blacklist . delete_expired ()","title":"Use the database blacklist"},{"location":"config/","text":"Jotbox can be configured with the following arguments encode_key Required This key is used to sign your JWTs. It is also used to verify them (unless a separate decode_key is specified) You should use a strong randomly generated string for this and store it securely. decode_key Default: encode_key When specified this token is used to decode your JWTs. (for use with asymmetric signing algorithms) payload_type Default: jotbox.Payload This is the model that is used for creating token payloads. You can subclass and add extra fields that you want encoded in the token. The default payload has the following standard claims: jti , iat , exp (optional) encode_algorithm Default: \"HS512\" Algorithm used to sign JWTs. This can be any algorithm supported by PyJWT. decode_algorithms Default: [\"HS512\", ] A list of algorithms that are accepted when decoding tokens. Any algorithms supported by PyJWT are accepted. leeway Default: 0 Number of seconds of leeway to allow when verifying things like expiry times and idle timeouts. It can be good to set this to a few seconds to account for clock skew. expires_in Default: None Number of seconds of how long new tokens are valid for. By default tokens never expire. The expiry time is encoded in the JWT as exp claim. idle_timeout Default: None Number of seconds before a token is deleted from whitelist due to inactivity. This can only be used when whitelist is provided. whitelist Default: None An instance of jotbox.whitelist.base.BaseWhitelist use as a storage backend for whitelisted tokens. Whitelisting is disabled when not provided. jwt_options Default: {} Dict of options forwarded to PyJWT.decode when verifying tokens.","title":"Configuration"},{"location":"payload-model/","text":"The Payload model The Payload is a pydantic model to control and validate the info that's encoded into the JWT. By default it contains the standard JWT claims: jti , iat , exp (optional) You can override it and customize like any pydantic model. E.g. add some user info and make expiry mandatory: from typing import List from jotbox import Payload class MyPayload ( Payload ): email : str permissions : List [ str ] exp : int Pass this to jotbox and use it. from jotbox import Jotbox jot = Jotbox [ MyPayload ]( encode_key = os . environ [ 'MY_SECRET_KEY' ], payload_type = MyPayload , expires_in = 3600 , ... ) Note : the [MyPayload] part of Jotbox[MyPayload] is not required but gives you type safety and better code completion in your IDE Now you can create tokens with your extra fields await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ] ) The arguments passed to create_token are validated with your payload model so passing invalid/wrong type arguments will fail. exp is added automatically by the expires_in setting by you can override it on a case by case basis by passing your own timestamp: import time import math await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ], exp = math . floor ( time . time () + 1800 ) )","title":"Payload model"},{"location":"payload-model/#the-payload-model","text":"The Payload is a pydantic model to control and validate the info that's encoded into the JWT. By default it contains the standard JWT claims: jti , iat , exp (optional) You can override it and customize like any pydantic model. E.g. add some user info and make expiry mandatory: from typing import List from jotbox import Payload class MyPayload ( Payload ): email : str permissions : List [ str ] exp : int Pass this to jotbox and use it. from jotbox import Jotbox jot = Jotbox [ MyPayload ]( encode_key = os . environ [ 'MY_SECRET_KEY' ], payload_type = MyPayload , expires_in = 3600 , ... ) Note : the [MyPayload] part of Jotbox[MyPayload] is not required but gives you type safety and better code completion in your IDE Now you can create tokens with your extra fields await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ] ) The arguments passed to create_token are validated with your payload model so passing invalid/wrong type arguments will fail. exp is added automatically by the expires_in setting by you can override it on a case by case basis by passing your own timestamp: import time import math await jot . create_token ( email = 'user@example.com' , permissions = [ 'articles-read' , 'articles-publish' ], exp = math . floor ( time . time () + 1800 ) )","title":"The Payload model"},{"location":"whitelist-and-revoke-tokens/","text":"Whitelist and revoke tokens This optional feature gives you the option of revoking tokens on demand or after a certain idle timeout . A revoked will fail verification. This requires a database backend to store tokens. Support for Redis is built in, but you can also roll your own. The whitelist works by storing the token ID ( jti ) every time you generate a token. The token is stored until its expiry time ( exp ) or idle timeout has elapsed (if your token have no expiry time and you don't use idle timeout they will be stored forever) When you call Jotbox.verified_payload it always checks the whitelist. If the token is not in whitelist it raises a jotbox.RevokedTokenerror Use the redis whitelist The built in redis whitelist is simple to use. Import it like this: from jotbox.whitelist.redis import RedisWhitelist Instantiate from redis URL: ... my_whitelist = RedisWhitelist ( 'redis://localhost' ) If you want more control over how the redis connection pool is created, you can pass in an aredis.StrictRedis instance directly: ... from aredis import StrictRedis my_redis = StrictRedis ( ... ) my_whitelist = RedisWhitelist ( my_redis ) You can also set a custom key prefix if you'd like (the default prefix is JB:WHITE: ): my_whitelist = RedisWhitelist ( my_redis , key_prefix = \"WHITELISTED_TOKEN:\" ) Now pass your whitelist when creating the Jotbox instance: jot = Jotbox [ MyPayload ]( ... , whitelist = my_whitelist ) To revoke a token (e.g. when a user logs out), pass the verified payload to revoke_payload : payload = await jot . verified_payload ( encoded_token ) await jot . revoke_payload ( payload ) Idle timeout The idle timeout setting tells jotbox to automatically delete tokens from the whitelist after a number of seconds of inactivity. When used in conjunction with expires_at the token is removed from whitelist once either the idle timeout or expiry time elapses, whichever happens first. This can be particularly useful for login sessions as it allows you to automatically log out the user after a period of inactivity while still allowing a long total expiry time on the session. To use this you need to pass both idle_timeout argument to Jotbox along with whitelist : jot = Jotbox [ MyPayload ]( ... , expires_at = 3600 * 24 , # Expire after 24 hours when not idle idle_timeout = 3600 , # Revoke after 1 hour of inactivity whitelist = my_whitelist ) token = await jot . create_token () encoded_token = token . token # User sends the token in API call valid_payload = await jot . verified_payload ( encoded_token ) # Success await asyncio . sleep ( 3601 ) # No activity during idle timeout await jot . verified_payload ( encoded_token ) # raises RevokedTokenerror(...) Use other storage backends You don't have to use redis for your whitelist. You can create a subclass of the abstract class jotbox.whitelist.base.BaseWhitelist and use any database/storage method you want. You'll need to implement the add , exists , touch and delete methods. Check source code of the redis whitelist for a reference implementation. Note that with redis, expiry times are handled by redis itself. With other databases you may need to explicitly check and clean up expired tokens.","title":"Whitelist and revoke tokens"},{"location":"whitelist-and-revoke-tokens/#whitelist-and-revoke-tokens","text":"This optional feature gives you the option of revoking tokens on demand or after a certain idle timeout . A revoked will fail verification. This requires a database backend to store tokens. Support for Redis is built in, but you can also roll your own. The whitelist works by storing the token ID ( jti ) every time you generate a token. The token is stored until its expiry time ( exp ) or idle timeout has elapsed (if your token have no expiry time and you don't use idle timeout they will be stored forever) When you call Jotbox.verified_payload it always checks the whitelist. If the token is not in whitelist it raises a jotbox.RevokedTokenerror","title":"Whitelist and revoke tokens"},{"location":"whitelist-and-revoke-tokens/#use-the-redis-whitelist","text":"The built in redis whitelist is simple to use. Import it like this: from jotbox.whitelist.redis import RedisWhitelist Instantiate from redis URL: ... my_whitelist = RedisWhitelist ( 'redis://localhost' ) If you want more control over how the redis connection pool is created, you can pass in an aredis.StrictRedis instance directly: ... from aredis import StrictRedis my_redis = StrictRedis ( ... ) my_whitelist = RedisWhitelist ( my_redis ) You can also set a custom key prefix if you'd like (the default prefix is JB:WHITE: ): my_whitelist = RedisWhitelist ( my_redis , key_prefix = \"WHITELISTED_TOKEN:\" ) Now pass your whitelist when creating the Jotbox instance: jot = Jotbox [ MyPayload ]( ... , whitelist = my_whitelist ) To revoke a token (e.g. when a user logs out), pass the verified payload to revoke_payload : payload = await jot . verified_payload ( encoded_token ) await jot . revoke_payload ( payload )","title":"Use the redis whitelist"},{"location":"whitelist-and-revoke-tokens/#idle-timeout","text":"The idle timeout setting tells jotbox to automatically delete tokens from the whitelist after a number of seconds of inactivity. When used in conjunction with expires_at the token is removed from whitelist once either the idle timeout or expiry time elapses, whichever happens first. This can be particularly useful for login sessions as it allows you to automatically log out the user after a period of inactivity while still allowing a long total expiry time on the session. To use this you need to pass both idle_timeout argument to Jotbox along with whitelist : jot = Jotbox [ MyPayload ]( ... , expires_at = 3600 * 24 , # Expire after 24 hours when not idle idle_timeout = 3600 , # Revoke after 1 hour of inactivity whitelist = my_whitelist ) token = await jot . create_token () encoded_token = token . token # User sends the token in API call valid_payload = await jot . verified_payload ( encoded_token ) # Success await asyncio . sleep ( 3601 ) # No activity during idle timeout await jot . verified_payload ( encoded_token ) # raises RevokedTokenerror(...)","title":"Idle timeout"},{"location":"whitelist-and-revoke-tokens/#use-other-storage-backends","text":"You don't have to use redis for your whitelist. You can create a subclass of the abstract class jotbox.whitelist.base.BaseWhitelist and use any database/storage method you want. You'll need to implement the add , exists , touch and delete methods. Check source code of the redis whitelist for a reference implementation. Note that with redis, expiry times are handled by redis itself. With other databases you may need to explicitly check and clean up expired tokens.","title":"Use other storage backends"}]}